import re
import functools
from datetime import datetime
import warnings
import os
import yaml

# logcat regex, which will match the log message generated by `adb logcat -v threadtime`
LOGCAT_THREADTIME_RE = re.compile(
    "^(?P<date>\S+)\s+(?P<time>\S+)\s+(?P<pid>[0-9]+)\s+(?P<tid>[0-9]+)\s+"
    "(?P<level>[VDIWEFS])\s+(?P<tag>[^:]*):\s+(?P<content>.*)$"
)


def lazy_property(func):
    attribute = "_lazy_" + func.__name__

    @property
    @functools.wraps(func)
    def wrapper(self):
        if not hasattr(self, attribute):
            setattr(self, attribute, func(self))
        return getattr(self, attribute)

    return wrapper


def parse_log(log_msg):
    """
    parse a logcat message
    the log should be in threadtime format
    @param log_msg:
    @return:
    """
    m = LOGCAT_THREADTIME_RE.match(log_msg)
    if not m:
        return None
    log_dict = {}
    date = m.group("date")
    time = m.group("time")
    log_dict["pid"] = m.group("pid")
    log_dict["tid"] = m.group("tid")
    log_dict["level"] = m.group("level")
    log_dict["tag"] = m.group("tag")
    log_dict["content"] = m.group("content")
    datetime_str = "%s-%s %s" % (datetime.today().year, date, time)
    log_dict["datetime"] = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S.%f")

    return log_dict


def get_available_devices():
    """
    Get a list of device serials connected via adb
    :return: list of str, each str is a device serial number
    """
    import subprocess

    r = subprocess.check_output(["adb", "devices"])
    if not isinstance(r, str):
        r = r.decode()
    devices = []
    for line in r.splitlines():
        segs = line.strip().split()
        if len(segs) == 2 and segs[1] == "device":
            devices.append(segs[0])
    return devices


def weighted_choice(choices):
    import random

    total = sum(choices[c] for c in list(choices.keys()))
    r = random.uniform(0, total)
    upto = 0
    for c in list(choices.keys()):
        if upto + choices[c] > r:
            return c
        upto += choices[c]


def safe_re_match(regex, content):
    if not regex or not content:
        return None
    else:
        return regex.match(content)


def md5(input_str):
    import hashlib

    return hashlib.md5(input_str.encode("utf-8")).hexdigest()


def get_yml_config() -> dict[str, str]:
    if not any(
        os.path.exists(ymal_path := os.path.join(os.getcwd(), _))
        for _ in ["config.yml", "config.yaml"]
    ):
        raise "config.yml not found"

    with open(ymal_path, "r") as fp:
        config_dict: dict[str, str] = yaml.safe_load(fp)

    return config_dict


def load_yml_args(opts, config_dict):
    for key, value in config_dict.items():
        if key.lower() == "system" and value:
            opts.is_harmonyos = value.lower() == "harmonyos"
            continue
        elif key.lower() == "app_path" and value:
            opts.apk_path = value
            continue
        elif key.lower() == "policy" and value:
            opts.input_policy = value
            continue
        elif key.lower() == "output_dir" and value:
            opts.output_dir = value
            continue
        elif key.lower() == "count" and value:
            opts.count = value
            continue
        elif key.lower() in ["target", "device", "device_serial"] and value:
            opts.device_serial = value
            continue
        
        if key.lower() != "env":
            setattr(opts, key, value)
        


def deprecated(reason):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            warnings.warn(
                f"Function '{func.__name__}' is deprecated: {reason}",
                DeprecationWarning,
                stacklevel=2,
            )
            return func(*args, **kwargs)

        return wrapper

    return decorator


def identify_device_serial(options):
    """
    automatically identify the device serial
    When no devices or more than one device is connected, an exception will be thrown.
    When only one device is connected, the current device's serial is used.
    """

    import subprocess

    if not options.is_harmonyos:
        cmd = ["adb", "devices"]
        r = subprocess.check_output(cmd, text=True)
        device_list = []
        for line in r.splitlines():
            if line and line.strip() != "List of devices attached":
                device_list.append(line.split()[0])
        if len(device_list) == 0:
            raise AttributeError("No connected device")
        if len(device_list) > 1:
            raise AttributeError(
                "More than one attached devices, please specify one device serial"
            )
        options.device_serial = device_list[0].strip()
    else:
        from .adapter.hdc import HDC_EXEC

        cmd = [HDC_EXEC, "list", "targets"]
        r = subprocess.check_output(cmd, text=True)
        device_list = [_.strip() for _ in r.splitlines()]
        if len(device_list) == 0:
            raise AttributeError("No connected device")
        if len(device_list) > 1:
            raise AttributeError(
                "More than one attached devices, please specify one device serial"
            )
        options.device_serial = device_list[0].strip()


def check_package(opts):
    if not hasattr(opts, "apk_path"):
        print("App package not provided")
        
    if not str(opts.apk_path).endswith(".hap"):
        print(f"[Warning] The given app {opts.apk_path} is probably a package name.")
        return
    
    if os.getcwd() not in opts.apk_path:
        opts.apk_path = os.path.join(os.getcwd(), opts.apk_path)
        
    if not os.path.exists(opts.apk_path):
        raise RuntimeError(f"App '{opts.apk_path}' does not exist.")
